{"name":"Capita Employee Benefits Tech Blog","tagline":"Capita EB Blog","body":"Problem\r\nOne of the challenges testing a system with a large domain and a complex data model is setting up fixtures to test against.\r\n\r\nOnce we move beyond unit tests and want to create real objects with real data – either as part of the setup stage of an automated test or for manually testing – then things become more challenging:\r\n\r\nThe data items we care about for the test may not all live on the object; our test might be interested in the payroll cut-off date for an employee for instance, but concerning ourselves with the details of where that data goes and the object graph needed to correctly set it all up is error prone and time consuming\r\nExtra code in our tests concerned with fixture details just adds noise to the test: it makes it harder to understand and adds to the maintenance burden.\r\nFalse-negatives: To get valid fixtures we might well have to set up other bits of data and other objects that our test just doesn’t care about, otherwise our tests fail for reasons unrelated to our test scenario\r\nFalse-positives: Tests might unwittingly pass because we’ve left fields empty that we don’t (think we) care about for the purposes of our test e.g. our test only works properly because something is null or false etc.\r\n\r\n\r\nInitial Solution\r\nAs an example let’s imagine a simple employee that we want to create for our test:\r\n\r\npublic class Employee {\r\n    String firstname;\r\n    String surname;\r\n    LocalDate dateOfBirth;\r\n    BigDecimal basicSalary;\r\n    Address homeAddress;\r\n    …\r\n}\r\n\r\nAnd some typical test code to create one:\r\n\r\npublic class EmployeeTest {\r\n    private final LocalDate DATE_OF_BIRTH = new LocalDate().minusYears(50);\r\n    private Employee employee;\r\n \r\n\r\n    @Before\r\n    public void setUpEmployee(){\r\n        employee = new Employee();\r\n        employee.setDateOfBirth(DATE_OF_BIRTH);\r\n    }\r\n}\r\n\r\nFor our test purposes we’re only interested in the age of our employee, but you can see we’re already getting bogged down with concerns about the rest of the data on our employee:\r\n\r\nwhat if the database requires non-null values for firstname and surname?\r\nwhat if the address is required too? Just what’s involved with making an Address object?\r\nwill it matter if the salary is not set to anything? I’m not interested in salary here but maybe I should make something up in case having a null salary makes something weird happen elsewhere.\r\nYou can imagine how quickly this complexity escalates with real code.\r\n\r\nImprovement - The Builder\r\nUsing the Builder Pattern to create our fixtures can address some of these issues:\r\n\r\nall the fields in our object are pre-populated\r\nwe only need to override the contents of the fields that we care about\r\nuse method chaining ending with build() to create our object\r\n\r\npublic class EmployeeBuilder {\r\n    private LocalDate dateOfBirth = new LocalDate().minusYears(30);\r\n    private String firstname = “Firstname”;\r\n    private String surname = “Surname”;\r\n    private BigDecimal basicSalary = new BigDecimal(20000);\r\n    private Address homeAddress = AddressBuilder.addressBuilder().build();\r\n    private EmployeeBuilder(){}\r\n    public static EmployeeBuilder employeeBuilder(){\r\n        return new EmployeeBuilder();\r\n    }\r\n    public EmployeeBuilder firstname(String firstname) {\r\n        this.firstname = firstname;\r\n        return this;\r\n    }\r\n    public EmployeeBuilder surname(String surname) {\r\n        this.surname = surname;\r\n        return this;\r\n    }\r\n    public EmployeeBuilder age(int age) {\r\n        this.dateOfBirth = new LocalDate().minusYears(age);\r\n        return this;\r\n    }\r\n    public EmployeeBuilder dateOfBirth(int age) {\r\n        this.dateOfBirth = new LocalDate().minusYears(age);\r\n        return this;\r\n    }\r\n    public EmployeeBuilder basicSalary(BigDecimal salary){\r\n        this.basicSalary = basicSalary;\r\n        return this;\r\n    }\r\n    public EmployeeBuilder basicSalary(Integer salary) {\r\n        this.basicSalary = new BigDecimal(salary);\r\n        return this;\r\n    }\r\n    public EmployeeBuilder homeAddress(Address address) {\r\n        this.homeAddress = homeAddress;\r\n        return this;\r\n    }\r\n    public Employee build(){\r\n        Employee employee = new Employee();\r\n        employee.setFirstname(firstname);\r\n        employee.setSurname(surname);\r\n        employee.setDateOfBirth(dateOfBirth);\r\n        employee.setBasicSalary(basicSalary);\r\n        employee.setHomeAddress(homeAddress);\r\n        return employee;\r\n    }\r\n\r\nThis makes our test setup look a bit nicer and takes away some of the concerns we were having:\r\n\r\npublic class EmployeeTest {\r\n    private final Integer AGE = 50;\r\n    private Employee employee;\r\n    @Before\r\n    public void setUpEmployee(){\r\n        employee = EmployeeBuilder.employeeBuilder().age(AGE).build();\r\n    }\r\n}\r\n\r\nA nice feature of builders is that you can add and overload methods to make fixture setup simpler:\r\n\r\nwe’ve overloaded basicSalary() so you can supply a simple Integer and it will convert it to the required BigDecimal for you\r\nthe dateOfBirth(LocalDate) method is accompanied by an age(Integer) method so you can make your test code simpler and more readable by avoiding the boilerplate of massaging a LocalDate\r\nFinally you may have noticed that the homeAddress field is populated initially with … an AddressBuilder!\r\n\r\nBetter Data\r\nWe’ve made our test setup a lot better with the builder but we can do better with the quality of the default data. At the moment every test that uses our builder is going to get an Employee with exactly the same default attributes which may create its own false-positive problem for us.\r\n\r\nWhat we need is random data:\r\n\r\npublic class EmployeeBuilder {\r\n    private Date dateOfBirth = Random.pastDate(years(17), years(64)).next();\r\n    private String firstname = Random.string(50).next();\r\n    private String surname = Random.string(50).next(); \r\n    private BigDecimal basicSalary = Random.bigDecimal(1000000).next();\r\n    private Address homeAddress = AddressBuilder.addressBuilder().build();\r\n    …\r\n\r\nWell this looks exciting! Let’s take a look at the Random class:\r\n\r\npublic class Random {\r\n    public static Generator<String> string = new StringGenerator(10);\r\n    public static Generator<Integer> integer = new IntegerGenerator(Integer.MAX_VALUE);\r\n    public static Generator<BigDecimal> bigDecimal = new BigDecimalGenerator(999999, 2);\r\n    …\r\nIt’s basically a collection of static Generator<T> members and some static helper methods.\r\n\r\nLet’s look at the Generator<T> and the IntegerGenerator classes:\r\n\r\npublic abstract class Generator<T> implements Iterator<T> {\r\n    @Override\r\n        public boolean hasNext() {\r\n        return true;\r\n    }\r\n    @Override\r\n    public void remove() {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\r\n \r\n\r\nclass IntegerGenerator extends Generator<Integer> {\r\n    private static java.util.Random random = new java.util.Random();\r\n    private Integer max;\r\n    public IntegerGenerator(Integer max) {\r\n        this.max = max;\r\n    }\r\n    @Override\r\n    public Integer next() {\r\n        return random.nextInt(max);\r\n    }\r\n}\r\n\r\nGenerator<T> is a never-ending abstract Iterator<T> implementation leaving it up to the extending classes to implement next().\r\n\r\nIntegerGenerator simply returns a new random integer between 0 and the specified maximum for each call to next(). You can see the default version provided by Random.integer uses Integer.MAX_VALUE when it creates it and it also provides a utility method to create your own IntegerGenerator with a different maximum if needed:\r\n\r\npublic static Generator<Integer> integer(Integer max) {\r\n    return new IntegerGenerator(max);\r\n}\r\n\r\nAnd that is the general idea with all the other types we want to generate.\r\n\r\nThe default Random.string implementation creates a StringGenerator that returns a 10-character long random string, Random.string(Integer) will give you a StringGenerator that generates a random string of the given length if you need it. There are also generators for dates, selecting enums at random and so on.\r\n\r\n\r\nGenerating data with tighter formatting is also a useful addition for tests - here’s an email address generator:\r\n\r\npublic class EmailAddressGenerator extends Generator<String> {\r\n    @Override\r\n    public String next() {\r\n        return format(\"%s@%s.%s\", Random.string(10).next(), Random.string(10).next(), Random.values(\"com\", \"co.uk\", \"gov.uk\" , \"org\", \"net\").next());\r\n    }\r\n}\r\n\r\nA postcode generator:\r\n\r\npublic class PostcodeGenerator extends Generator<String> {\r\n    @Override\r\n    public String next() {\r\n        return format(\"%s%s%01d %01d%s\",\r\n            random(1, \"ABCDEFGHIJKLMNOPRSTUWYZ\"),\r\n            random(1, \"ABCDEFGHKLMNOPQRSTUVWXY\"),\r\n            Random.integer(9).next(),\r\n            Random.integer(9).next(),\r\n            random(2, \"ABDEFGHJLNPQRSTUWXYZ\"));\r\n    }\r\n}\r\n\r\nAnd a random URI generator:\r\n\r\npublic class UriGenerator extends Generator<URI> {\r\n    @Override\r\n    public URI next() {\r\n        try {\r\n            return new URI(String.format(\"http://%s.%s\", Random.string.next(), Random.values(\"com\", \"co.uk\", \"org\").next()));\r\n        } catch (URISyntaxException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}\r\nWe have an collection of these utils in our repository here.\r\n\r\nIn future posts we’ll look at how to reproduce the random data used in test failures in the build and how to manage more complicated fixture setups.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}